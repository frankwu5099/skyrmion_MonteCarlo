# This Module provides "MCdata" object to load the data generated by Monte Carlo simulation.
# Make sure your simulation data generated by the version 2.0 or later, or you need to use details2config.py in ../tools to do the conversion first.
# by Po-Kuan Wu

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sn
import json
from pathlib import Path

def bootstrap(df:pd.DataFrame, columns:list, func = None, n_resample = 1000):
    """ A method for bootstrap resampling.
    This resampling is specialied for the MCdata.rawdata, and it can estimate the mean and the
    standart error for the binning measurements (columns).

    Args:
        df : rawdata of MCdata
        columns: the columns for resampling if func is None
                 If func is not None, the column should be the parameters for the function.
        func: Function for the property to return. If it is None, just return the mean and
              standard error for columns.
        n_resampling: Number of bootstrap resampling. Default:1000
    return:
        func is None:
            Mean and std error of columns
        func is not None:
            Mean and std error of func(*columns)

    """
    NumBin = len(df.Bin.unique())
    dataCB = []
    for column in columns:
        dataCB.append([df[df.Bin == i][column] for i in range(NumBin)])
    dataCB = np.array(dataCB)
    data_resample = np.zeros((dataCB.shape[0],n_resample,dataCB.shape[2]))
    for resample in range(n_resample):
        for i in np.random.choice(NumBin,NumBin):
            data_resample[:,resample,:] += dataCB[:,i,:]
    data_resample /= NumBin
    if func is None:
        return data_resample.mean(axis = 1),data_resample.std(axis = 1)
    else:
        distribution = func(*data_resample)
        return distribution.mean(axis = 0), distribution.std(axis = 0)



class MCdata:
    """
    data for the Monte Carlo simulation
    Attribute:
        config: configuration of the simulation
        ensemble: configuration of the ensemble
        params: hyperparameters of the simulation
        rawdata: a DataFrame with the results of all bins
    """
    def __init__(self, simdir, measurements = None):
        """
        args:
            simdir: path of the directory of simulation
            measurements: the properties need to be included in rawdata
        """
        self.simdir = Path(simdir)
        with open(str(self.simdir / "config.json"), 'r') as f:
            self.config = json.load(f)
        self.params = self.config["parameters"]
        self.ensemble = self.config["ensemble"]
        if measurements == None:
            self.measurements = ["Chern","M","M2","M4","E","E2"]
        else:
            self.measurements = measurements
        datam = {}
        for i in self.measurements:
            datam[i] = np.fromfile(str(self.simdir / i),dtype = np.float64)
        self.NumBin = self.params["BIN_NUM"]
        self.NumP = self.ensemble['NumHaxis'] * self.ensemble['NumTaxis']
        self.rawdata = pd.DataFrame({"temperature":np.tile(self.ensemble["Ts"],self.NumBin),
                                      "field":np.tile(self.ensemble["Hs"],self.NumBin),
                                      "Bin": np.repeat(np.arange(self.NumBin),self.NumP), **datam})
        
    def pointdata(self, measurements = None, bootstrap_on = True, standard_error = True):
        """
        use bootstrap or trivial method to get the mean value and the error for each
        point (temperature, field) on phase diagram.
        args:
            measurements: the properties need to be included in rawdata
            bootstrap_on: use bootstrap resampling or not
            standard_error: whether output obtain the standard error or not
        """
        dfpoints = self.rawdata[self.rawdata.Bin == 0].drop(columns = ["Bin"]+ self.measurements).reset_index(drop = True)
        if measurements == None:
            measurements = self.measurements
        measurements_error = []
        if standard_error:
            measurements_error = [i + "_err" for i in measurements]
        if bootstrap_on:
            mmeans,merr = bootstrap(self.rawdata, measurements)
            for i, avg in enumerate (measurements):
                dfpoints[avg] = mmeans[i]
            for i, err in enumerate (measurements_error):
                dfpoints[err] = merr[i]
        else:
            for i in measurements:
                dfpoints[i] = self.rawdata.groupby(["field","temperature"])[i].mean().reset_index(drop=True)
            for m,merr in zip(measurements, measurements_error):
                dfpoints[merr] = self.rawdata.groupby(["field","temperature"])[m].std().reset_index(drop=True)
        return dfpoints


